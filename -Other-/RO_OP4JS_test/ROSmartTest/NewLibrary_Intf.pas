unit NewLibrary_Intf;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROClient, uROTypes, uROClientIntf;

const
  //RBK modification: storing timestamp of generation, to be able to check version mismatch between client and server
  //RBK modification, done in: "\Lib\Componenten\RemObjects SDK for Delphi\Source\CodeGen\uRODLToPascalIntf.pas"
  C_GenerateDateTime = '12-01-2012 09:08:12:560 by amussche';

const
  { Library ID }
  LibraryUID = '{3BBA0AE3-7D1A-4CAE-A1E4-7586B43DBA03}';
  TargetNamespace = '';

  { Service Interface ID's }
  INewService_IID : TGUID = '{68628221-673A-4291-BB33-0D7ED0A6F935}';

type
  TSeekOrigin = Classes.TSeekOrigin; // fake declaration
  { Forward declarations }
  INewService = interface;

  NewStruct = class;

  { NewStruct }
  NewStruct = class(TROComplexType)
  private
    fNewField: AnsiString;
    fNewField1: AnsiString;
  public
    procedure Assign(iSource: TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
  published
    property NewField:AnsiString read fNewField write fNewField;
    property NewField1:AnsiString read fNewField1 write fNewField1;
  end;

  { NewStructCollection }
  NewStructCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: integer): NewStruct;
    procedure SetItems(aIndex: integer; const Value: NewStruct);
  public
    constructor Create; overload;
    function Add: NewStruct; reintroduce;
    property Items[Index: integer]:NewStruct read GetItems write SetItems; default;
  end;


  { INewService }
  INewService = interface
    ['{68628221-673A-4291-BB33-0D7ED0A6F935}']
    function Sum(const A: Integer; const B: Integer): Integer;
    function GetServerTime: DateTime;
    function NewMethod: NewStruct;
  end;

  { CoNewService }
  CoNewService = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
  end;

  { TNewService_Proxy }
  TNewService_Proxy = class(TROProxy, INewService)
  protected
    function __GetInterfaceName:string; override;

    function Sum(const A: Integer; const B: Integer): Integer;
    function GetServerTime: DateTime;
    function NewMethod: NewStruct;
  end;

implementation

uses
  {vcl:} SysUtils,
  {RemObjects:} uROEventRepository, uROSerializer, uRORes;

{ NewStruct }

procedure NewStruct.Assign(iSource: TPersistent);
var
  lSource: NewLibrary_Intf.NewStruct;
begin
  inherited Assign(iSource);
  if (iSource is NewLibrary_Intf.NewStruct) then begin
    lSource := NewLibrary_Intf.NewStruct(iSource);

    NewField := lSource.NewField;
    NewField1 := lSource.NewField1;
  end;
end;

procedure NewStruct.ReadComplex(ASerializer: TObject);
var
  l_NewField: AnsiString;
  l_NewField1: AnsiString;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    l_NewField := NewField;
    TROSerializer(ASerializer).ReadAnsiString('NewField', l_NewField);
    NewField := l_NewField;
    l_NewField1 := NewField1;
    TROSerializer(ASerializer).ReadAnsiString('NewField1', l_NewField1);
    NewField1 := l_NewField1;
  end
  else begin
    l_NewField := NewField;
    TROSerializer(ASerializer).ReadAnsiString('NewField', l_NewField);
    NewField := l_NewField;
    l_NewField1 := NewField1;
    TROSerializer(ASerializer).ReadAnsiString('NewField1', l_NewField1);
    NewField1 := l_NewField1;
  end;
end;

procedure NewStruct.WriteComplex(ASerializer: TObject);
var
  l_NewField: AnsiString;
  l_NewField1: AnsiString;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    TROSerializer(ASerializer).ChangeClass(NewStruct);
    l_NewField := NewField;
    TROSerializer(ASerializer).WriteAnsiString('NewField', l_NewField);
    l_NewField1 := NewField1;
    TROSerializer(ASerializer).WriteAnsiString('NewField1', l_NewField1);
  end
  else begin
    l_NewField := NewField;
    TROSerializer(ASerializer).WriteAnsiString('NewField', l_NewField);
    l_NewField1 := NewField1;
    TROSerializer(ASerializer).WriteAnsiString('NewField1', l_NewField1);
  end;
end;

{ NewStructCollection }
constructor NewStructCollection.Create;
begin
  inherited Create(NewStruct);
end;

constructor NewStructCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function NewStructCollection.Add: NewStruct;
begin
  Result := NewStruct(inherited Add);
end;

function NewStructCollection.GetItems(aIndex: integer): NewStruct;
begin
  Result := NewStruct(inherited Items[aIndex]);
end;

procedure NewStructCollection.SetItems(aIndex: integer; const Value: NewStruct);
begin
  NewStruct(inherited Items[aIndex]).Assign(Value);
end;

{ CoNewService }

class function CoNewService.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
begin
  Result := TNewService_Proxy.Create(aMessage, aTransportChannel);
end;

{ TNewService_Proxy }

function TNewService_Proxy.__GetInterfaceName:string;
begin
  Result := 'NewService';
end;

function TNewService_Proxy.Sum(const A: Integer; const B: Integer): Integer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'Sum');
    lMessage.Write('A', TypeInfo(Integer), A, []);
    lMessage.Write('B', TypeInfo(Integer), B, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(Integer), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.GetServerTime: DateTime;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'GetServerTime');
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(DateTime), Result, [paIsDateTime]);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.NewMethod: NewStruct;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'NewMethod');
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(NewLibrary_Intf.NewStruct), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

initialization
  RegisterROClass(NewStruct);
  RegisterProxyClass(INewService_IID, TNewService_Proxy);


finalization
  UnregisterROClass(NewStruct);
  UnregisterProxyClass(INewService_IID);


end.
