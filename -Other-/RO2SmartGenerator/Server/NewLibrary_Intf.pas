unit NewLibrary_Intf;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROClient, uROTypes, uROClientIntf;

const
  //RBK modification: storing timestamp of generation, to be able to check version mismatch between client and server
  //RBK modification, done in: "\Lib\Componenten\RemObjects SDK for Delphi\Source\CodeGen\uRODLToPascalIntf.pas"
  C_GenerateDateTime = '16-05-2012 10:35:22:638 by amussche';

const
  { Library ID }
  LibraryUID = '{05E0C9DE-D4DA-4DF3-B11B-16F8BA019F10}';
  TargetNamespace = '';

  { Service Interface ID's }
  INewService_IID : TGUID = '{56229586-01AD-440D-BE37-1EB6D56C0CA2}';

type
  TSeekOrigin = Classes.TSeekOrigin; // fake declaration
  { Forward declarations }
  INewService = interface;

  { Enumerateds }
  NewEnum = (
    Enum1,
    Enum2,
    Enum3
  );


  { INewService }
  INewService = interface
    ['{56229586-01AD-440D-BE37-1EB6D56C0CA2}']
    function Sum(const A: Integer; const B: Integer): Integer;
    function GetServerTime: DateTime;
    function TestParams(const InParamInt: Integer; const InParamAnsi: AnsiString; const InParamBool: Boolean; const InParamCur: Currency;
                        const InParamDatetime: DateTime; const InParamDec: Decimal; const InParamDouble: Double; const InParamInt64: Int64;
                        const InParamUtf8: Utf8String; const InParamWide: UnicodeString; out OutParamAnsi: AnsiString; out OutParamBool: Boolean;
                        out OutParamCurr: Currency; out OutParamDatetime: DateTime; out OutParamDec: Decimal; out OutParamDouble: Double;
                        out OutParamInt64: Int64; out OutParamInt: Integer; out OutParamUtf8: Utf8String; out OutParamWide: UnicodeString;
                        var InOutParam: AnsiString): Boolean;
    function TestEnum(const NewParam: NewEnum): NewEnum;
  end;

  { CoNewService }
  CoNewService = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
  end;

  { TNewService_Proxy }
  TNewService_Proxy = class(TROProxy, INewService)
  protected
    function __GetInterfaceName:string; override;

    function Sum(const A: Integer; const B: Integer): Integer;
    function GetServerTime: DateTime;
    function TestParams(const InParamInt: Integer; const InParamAnsi: AnsiString; const InParamBool: Boolean; const InParamCur: Currency;
                        const InParamDatetime: DateTime; const InParamDec: Decimal; const InParamDouble: Double; const InParamInt64: Int64;
                        const InParamUtf8: Utf8String; const InParamWide: UnicodeString; out OutParamAnsi: AnsiString; out OutParamBool: Boolean;
                        out OutParamCurr: Currency; out OutParamDatetime: DateTime; out OutParamDec: Decimal; out OutParamDouble: Double;
                        out OutParamInt64: Int64; out OutParamInt: Integer; out OutParamUtf8: Utf8String; out OutParamWide: UnicodeString;
                        var InOutParam: AnsiString): Boolean;
    function TestEnum(const NewParam: NewEnum): NewEnum;
  end;

implementation

uses
  {vcl:} SysUtils,
  {RemObjects:} uROEventRepository, uROSerializer, uRORes;

{ CoNewService }

class function CoNewService.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
begin
  Result := TNewService_Proxy.Create(aMessage, aTransportChannel);
end;

{ TNewService_Proxy }

function TNewService_Proxy.__GetInterfaceName:string;
begin
  Result := 'NewService';
end;

function TNewService_Proxy.Sum(const A: Integer; const B: Integer): Integer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'Sum');
    lMessage.Write('A', TypeInfo(Integer), A, []);
    lMessage.Write('B', TypeInfo(Integer), B, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(Integer), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.GetServerTime: DateTime;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'GetServerTime');
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(DateTime), Result, [paIsDateTime]);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.TestParams(const InParamInt: Integer; const InParamAnsi: AnsiString; const InParamBool: Boolean; const InParamCur: Currency;
                                      const InParamDatetime: DateTime; const InParamDec: Decimal; const InParamDouble: Double; const InParamInt64: Int64;
                                      const InParamUtf8: Utf8String; const InParamWide: UnicodeString; out OutParamAnsi: AnsiString; out OutParamBool: Boolean;
                                      out OutParamCurr: Currency; out OutParamDatetime: DateTime; out OutParamDec: Decimal; out OutParamDouble: Double;
                                      out OutParamInt64: Int64; out OutParamInt: Integer; out OutParamUtf8: Utf8String; out OutParamWide: UnicodeString;
                                      var InOutParam: AnsiString): Boolean;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'TestParams');
    lMessage.Write('InParamInt', TypeInfo(Integer), InParamInt, []);
    lMessage.Write('InParamAnsi', TypeInfo(AnsiString), InParamAnsi, []);
    lMessage.Write('InParamBool', TypeInfo(Boolean), InParamBool, []);
    lMessage.Write('InParamCur', TypeInfo(Currency), InParamCur, []);
    lMessage.Write('InParamDatetime', TypeInfo(DateTime), InParamDatetime, [paIsDateTime]);
    lMessage.Write('InParamDec', TypeInfo(Decimal), InParamDec, []);
    lMessage.Write('InParamDouble', TypeInfo(Double), InParamDouble, []);
    lMessage.Write('InParamInt64', TypeInfo(Int64), InParamInt64, []);
    lMessage.Write('InParamUtf8', TypeInfo(Utf8String), InParamUtf8, []);
    lMessage.Write('InParamWide', TypeInfo(UnicodeString), InParamWide, []);
    lMessage.Write('InOutParam', TypeInfo(AnsiString), InOutParam, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(Boolean), Result, []);
    lMessage.Read('OutParamAnsi', TypeInfo(AnsiString), OutParamAnsi, []);
    lMessage.Read('OutParamBool', TypeInfo(Boolean), OutParamBool, []);
    lMessage.Read('OutParamCurr', TypeInfo(Currency), OutParamCurr, []);
    lMessage.Read('OutParamDatetime', TypeInfo(DateTime), OutParamDatetime, [paIsDateTime]);
    lMessage.Read('OutParamDec', TypeInfo(Decimal), OutParamDec, []);
    lMessage.Read('OutParamDouble', TypeInfo(Double), OutParamDouble, []);
    lMessage.Read('OutParamInt64', TypeInfo(Int64), OutParamInt64, []);
    lMessage.Read('OutParamInt', TypeInfo(Integer), OutParamInt, []);
    lMessage.Read('OutParamUtf8', TypeInfo(Utf8String), OutParamUtf8, []);
    lMessage.Read('OutParamWide', TypeInfo(UnicodeString), OutParamWide, []);
    lMessage.Read('InOutParam', TypeInfo(AnsiString), InOutParam, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

function TNewService_Proxy.TestEnum(const NewParam: NewEnum): NewEnum;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'TestEnum');
    lMessage.Write('NewParam', TypeInfo(NewLibrary_Intf.NewEnum), NewParam, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('Result', TypeInfo(NewLibrary_Intf.NewEnum), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

initialization
  RegisterProxyClass(INewService_IID, TNewService_Proxy);

  RegisterROEnum('NewEnum',TypeInfo(NewLibrary_Intf.NewEnum));
  RegisterEnumMapping('NewEnum', 'Enum1', 'Enum1');
  RegisterEnumMapping('NewEnum', 'Enum2', 'Enum2');
  RegisterEnumMapping('NewEnum', 'Enum3', 'Enum3');

finalization
  UnregisterProxyClass(INewService_IID);


  UnRegisterEnumMappings('NewEnum');
  UnregisterROEnum('NewEnum');
end.
