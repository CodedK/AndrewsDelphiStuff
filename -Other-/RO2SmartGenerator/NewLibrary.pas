unit NewLibrary;

//----------------------------------------------------------------------------//
// This unit was automatically generated by the RemObjects SDK after reading  //
// the RODL file associated with this project .                               //
//                                                                            //
// Do not modify this unit manually, or your changes will be lost when this   //
// unit is regenerated the next time you compile the project.                 //
//----------------------------------------------------------------------------//

interface

uses
  w3system;

(* This codegen depends on RemObjects.js -> add reference in index.html
* Usage:
*  var channel := THTTPChannel.Create("http://localhost:8099/JSON");
*  var msg     := TJSONMessage.Create();
*  var service := CoNewService.Create(msg as IROMessage, channel as IROTransportChannel);
*  service.Sum(1, 2,
*    procedure(aResult: Integer)
*    begin
*      w3_ShowMessage('Result = ' + IntToStr(aResult) );
*    end);
*)

const
  TargetNamespace = 'NewLibrary';

  { Event ID's }

type
  {RO types}
  DateTime = TDateTime;
  AnsiString = string;
  Currency = Double;
  Decimal = Double;
  Int64 = Integer;
  Utf8String = string;
  WideString = string;

  {RO interfaces}
  IROTransport = interface
  end;

  IROMessage = interface
    procedure InitializeRequestMessage(aTransport : IROTransport; aLibraryName, anInterfaceName, aMessageName : string);
    procedure Write(aName : string; aTypeInfo : string; aValue: variant);
    //procedure Read (aName : string; aTypeInfo : string; var aValue: variant);
    function  Read (aName : string; aTypeInfo : string): Variant;
    procedure Finalize;

    procedure UnsetAttributes(aTransport: IROTransport);
    procedure FreeStream;

    function  Clone: IROMessage;
  end;

  {RO message classes}
  TMessage = class(TObject,
                   IROMessage)
  public
    fROMessage: Variant;

    procedure InitializeRequestMessage(aTransport : IROTransport; aLibraryName, anInterfaceName, aMessageName : string);
    procedure Write(aName : string; aTypeInfo : string; aValue: variant);
    function  Read (aName : string; aTypeInfo : string): Variant;
    procedure Finalize;

    procedure UnsetAttributes(aTransport: IROTransport);
    procedure FreeStream;

    function  Clone: IROMessage;
  end;

  TJSONMessage = class(TMessage)
  public
    constructor Create();
  end;

  {RO channels}
  TDispatchResult = procedure(aResult: Variant);

  IROTransportChannel = interface(IROTransport)
      procedure Dispatch(aMessage: IROMessage; aCallback: TDispatchResult);
  end;

  TChannel = class(TObject,
                   IROTransportChannel)
  protected
    procedure Dispatch(aMessage: IROMessage; aCallback: TDispatchResult);
  public
    fROChannel: Variant;
  end;

  THTTPChannel = class(TChannel)
  public
    constructor Create(aURL: string);
  end;

  {RO base proxy class}
  TROProxy = class
  protected
    FMessage: IROMessage;
    FTransportChannel: IROTransportChannel;

    function __GetInterfaceName:string; virtual; abstract;
    function __GetMessage : IROMessage; virtual;
    function __GetTransportChannel: IROTransportChannel;
  public
    constructor Create(aMessage : IROMessage; aTransportChannel : IROTransportChannel); virtual;
  end;

  { Forward declarations }
  INewService = interface;

  { Enumerateds }
const
  NewLibrary_NewEnum = [
      "Enum1",
      "Enum2",
      "Enum3"
      ];
type
  NewEnum = (
    Enum1,
    Enum2,
    Enum3
    );

  { Exceptions }

  { INewService }
  { Callback definitions }
  TNewService_Sum_Result = procedure(aResult: Integer
                        );
  TNewService_GetServerTime_Result = procedure(aResult: DateTime);
  TNewService_TestParams_Result = procedure(aResult: Boolean
                        ; aOutParamAnsi: AnsiString
                        ; aOutParamBool: Boolean
                        ; aOutParamCurr: Currency
                        ; aOutParamDatetime: DateTime
                        ; aOutParamDec: Decimal
                        ; aOutParamDouble: Double
                        ; aOutParamInt64: Int64
                        ; aOutParamInt: Integer
                        ; aOutParamUtf8: Utf8String
                        ; aOutParamWide: UnicodeString
                        ; aInOutParam: AnsiString
                        );
  TNewService_TestEnum_Result = procedure(aResult: NewEnum
                        );
  { Service definition }
  INewService = interface 
    procedure Sum(
               const A: Integer;
               const B: Integer;
               aCallback: TNewService_Sum_Result
               );
    procedure GetServerTime(aCallback: TNewService_GetServerTime_Result);
    procedure TestParams(
               const InParamInt: Integer;
               const InParamAnsi: AnsiString;
               const InParamBool: Boolean;
               const InParamCur: Currency;
               const InParamDatetime: DateTime;
               const InParamDec: Decimal;
               const InParamDouble: Double;
               const InParamInt64: Int64;
               const InParamUtf8: Utf8String;
               const InParamWide: UnicodeString;
               var InOutParam: AnsiString;
               aCallback: TNewService_TestParams_Result
               );
    procedure TestEnum(
               const NewParam: NewEnum;
               aCallback: TNewService_TestEnum_Result
               );
  end;

  { CoNewService }
  CoNewService = class
    class function Create(aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
  end;

  { TNewService_Proxy }
  TNewService_Proxy = class(TROProxy, //TROProxy, todo: ancestors?
                                INewService)
  protected
    function __GetInterfaceName:string; override;

    procedure Sum(
               const A: Integer;
               const B: Integer;
               aCallback: TNewService_Sum_Result);
    procedure GetServerTime(aCallback: TNewService_GetServerTime_Result);
    procedure TestParams(
               const InParamInt: Integer;
               const InParamAnsi: AnsiString;
               const InParamBool: Boolean;
               const InParamCur: Currency;
               const InParamDatetime: DateTime;
               const InParamDec: Decimal;
               const InParamDouble: Double;
               const InParamInt64: Int64;
               const InParamUtf8: Utf8String;
               const InParamWide: UnicodeString;
               var InOutParam: AnsiString;
               aCallback: TNewService_TestParams_Result);
    procedure TestEnum(
               const NewParam: NewEnum;
               aCallback: TNewService_TestEnum_Result);
  public
    constructor Create(aMessage: IROMessage; aTransportChannel: IROTransportChannel); override;
  end;

implementation

{ CoNewService }

class function CoNewService.Create(aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService;
begin
  Result := TNewService_Proxy.Create(aMessage, aTransportChannel);
end;

{ TNewService_Proxy }

function TNewService_Proxy.__GetInterfaceName:string;
begin
  Result := 'NewService';
end;

constructor TNewService_Proxy.Create(aMessage: IROMessage; aTransportChannel: IROTransportChannel);
begin
  inherited Create(aMessage, aTransportChannel);

  asm
    //this.fServiceName = this.fServiceName || @__GetInterfaceName || "NewService";
    this.fServiceName = "NewService";
  end;
end;

procedure TNewService_Proxy.Sum(
           const A: Integer;
           const B: Integer;
           aCallback: TNewService_Sum_Result);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage.Clone;
  lTransportChannel := __GetTransportChannel;
  lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __GetInterfaceName, 'Sum');
  lMessage.Write('A', "Integer", A);
  lMessage.Write('B', "Integer", B);
  lMessage.Finalize;

  lTransportChannel.Dispatch(lMessage,
      procedure(resultmsg: Variant)
      begin
        var msg := TMessage.Create;  //create message reader as wrapper
        msg.fROMessage := resultmsg;

        var vResult := msg.Read('Result', "Integer");
        aCallback(vResult
          );
      end);
end;

procedure TNewService_Proxy.GetServerTime(aCallback: TNewService_GetServerTime_Result);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage.Clone;
  lTransportChannel := __GetTransportChannel;
  lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __GetInterfaceName, 'GetServerTime');
  lMessage.Finalize;

  lTransportChannel.Dispatch(lMessage,
      procedure(resultmsg: Variant)
      begin
        var msg := TMessage.Create;  //create message reader as wrapper
        msg.fROMessage := resultmsg;

        var vResult := msg.Read('Result', "DateTime");
        aCallback(vResult
          );
      end);
end;

procedure TNewService_Proxy.TestParams(
           const InParamInt: Integer;
           const InParamAnsi: AnsiString;
           const InParamBool: Boolean;
           const InParamCur: Currency;
           const InParamDatetime: DateTime;
           const InParamDec: Decimal;
           const InParamDouble: Double;
           const InParamInt64: Int64;
           const InParamUtf8: Utf8String;
           const InParamWide: UnicodeString;
           var InOutParam: AnsiString;
           aCallback: TNewService_TestParams_Result);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage.Clone;
  lTransportChannel := __GetTransportChannel;
  lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __GetInterfaceName, 'TestParams');
  lMessage.Write('InParamInt', "Integer", InParamInt);
  lMessage.Write('InParamAnsi', "AnsiString", InParamAnsi);
  lMessage.Write('InParamBool', "Boolean", InParamBool);
  lMessage.Write('InParamCur', "Currency", InParamCur);
  lMessage.Write('InParamDatetime', "DateTime", InParamDatetime);
  lMessage.Write('InParamDec', "Decimal", InParamDec);
  lMessage.Write('InParamDouble', "Double", InParamDouble);
  lMessage.Write('InParamInt64', "Int64", InParamInt64);
  lMessage.Write('InParamUtf8', "Utf8String", InParamUtf8);
  lMessage.Write('InParamWide', "UnicodeString", InParamWide);
  lMessage.Write('InOutParam', "AnsiString", InOutParam);
  lMessage.Finalize;

  lTransportChannel.Dispatch(lMessage,
      procedure(resultmsg: Variant)
      begin
        var msg := TMessage.Create;  //create message reader as wrapper
        msg.fROMessage := resultmsg;

        var vResult := msg.Read('Result', "Boolean");
        var vOutParamAnsi := msg.Read('OutParamAnsi', "AnsiString");
        var vOutParamBool := msg.Read('OutParamBool', "Boolean");
        var vOutParamCurr := msg.Read('OutParamCurr', "Currency");
        var vOutParamDatetime := msg.Read('OutParamDatetime', "DateTime");
        var vOutParamDec := msg.Read('OutParamDec', "Decimal");
        var vOutParamDouble := msg.Read('OutParamDouble', "Double");
        var vOutParamInt64 := msg.Read('OutParamInt64', "Int64");
        var vOutParamInt := msg.Read('OutParamInt', "Integer");
        var vOutParamUtf8 := msg.Read('OutParamUtf8', "Utf8String");
        var vOutParamWide := msg.Read('OutParamWide', "UnicodeString");
        var vInOutParam := msg.Read('InOutParam', "AnsiString");
        aCallback(vResult
                  , vOutParamAnsi
                  , vOutParamBool
                  , vOutParamCurr
                  , vOutParamDatetime
                  , vOutParamDec
                  , vOutParamDouble
                  , vOutParamInt64
                  , vOutParamInt
                  , vOutParamUtf8
                  , vOutParamWide
                  , vInOutParam
          );
      end);
end;

procedure TNewService_Proxy.TestEnum(
           const NewParam: NewEnum;
           aCallback: TNewService_TestEnum_Result);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage.Clone;
  lTransportChannel := __GetTransportChannel;
  lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __GetInterfaceName, 'TestEnum');
  lMessage.Write('NewParam', "NewLibrary.NewEnum", NewParam);
  lMessage.Finalize;

  lTransportChannel.Dispatch(lMessage,
      procedure(resultmsg: Variant)
      begin
        var msg := TMessage.Create;  //create message reader as wrapper
        msg.fROMessage := resultmsg;

        var vResult := msg.Read('Result', "NewLibrary.NewEnum");
        aCallback(vResult
          );
      end);
end;

procedure TMessage.InitializeRequestMessage(aTransport: IROTransport; aLibraryName, anInterfaceName, aMessageName : string);
begin
  fROMessage.initialize(anInterfaceName, aMessageName);
end;

procedure TMessage.Write(aName: string; aTypeInfo: string; aValue: variant);
begin
  if aTypeInfo = 'DateTime' then
  begin
    //todo: DatetimeToISO8601
    fROMessage.write(aName, aTypeInfo, "2012-05-15T22:00:00Z");
  end
  else if aTypeInfo = 'NewLibrary.NewEnum' then
  begin
    fROMessage.write(aName, aTypeInfo, NewLibrary_NewEnum[aValue]); //get string value by index
  end
  else
    fROMessage.write(aName, aTypeInfo, aValue);
end;

function TMessage.Read(aName: string; aTypeInfo: string): Variant;
begin
  if aTypeInfo = 'DateTime' then
  begin
    Result := fROMessage.read(aName, aTypeInfo);
  end
  else if aTypeInfo = 'NewLibrary.NewEnum' then
  begin
    Result := fROMessage.read(aName, aTypeInfo);
    //get index of string value
    var i: Integer;
    for i := 0 to NewLibrary_NewEnum.length() do
    begin
      if NewLibrary_NewEnum[i] = Result then
      begin
        Result := i;
        Break;
      end;
    end;
  end
  else
    Result := fROMessage.read(aName, aTypeInfo);
end;

procedure TMessage.Finalize;
begin
  fROMessage.finalize();
end;

procedure TMessage.UnsetAttributes(aTransport: IROTransport);
begin
  //
end;

procedure TMessage.FreeStream;
begin
  //
end;

function TMessage.Clone: IROMessage;
begin
  Result := TMessage.Create;
  (Result as TMessage).fROMessage := fROMessage.clone();
end;

constructor TJSONMessage.Create();
var
  msg: Variant;
begin
  asm
    @msg = new RemObjects.SDK.JSONMessage();
  end;
  fROMessage := msg;
end;

procedure TChannel.Dispatch(aMessage: IROMessage; aCallback: TDispatchResult);
var
  msg: Variant;
begin
  msg := (aMessage as TMessage).fROMessage;
  fROChannel.dispatch(msg, @aCallback,
    procedure(aMessage, aError: Variant)
    begin
      var sMsg: string;
      asm
        @sMsg = JSON.stringify(@aMessage);
      end;
      w3_ShowMessage('Error: ' + aError.toString() + #13 + 'Message: ' + sMsg);
    end);
end;

constructor THTTPChannel.Create(aURL: string);
var
  ch: variant;
begin
  asm
    @ch = new RemObjects.SDK.HTTPClientChannel(@aURL);
  end;
  fROChannel := ch;
end;

function TROProxy.__GetMessage: IROMessage;
begin
  Result := FMessage;
end;

function TROProxy.__GetTransportChannel: IROTransportChannel;
begin
  Result := FTransportChannel;
end;

constructor TROProxy.Create(aMessage: IROMessage; aTransportChannel: IROTransportChannel);
var
  ch, msg, sid: Variant;
begin
  FMessage          := aMessage;
  FTransportChannel := aTransportChannel;

  ch  := (aTransportChannel as TChannel).fROChannel;
  msg := (aMessage as TMessage).fROMessage;
  sid := __GetInterfaceName;
  asm
    //init this object
    RemObjects.SDK.ROService.call(this, @ch, @msg, @sid);
  end
end;

end.
