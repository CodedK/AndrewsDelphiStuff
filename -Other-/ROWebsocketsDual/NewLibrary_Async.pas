unit NewLibrary_Async;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROTypes, uROClientIntf, uROAsync,
  {Project:} NewLibrary_Intf;

type
  TSeekOrigin = Classes.TSeekOrigin; // fake declaration
  { INewService_Async }
  INewService_Async = interface(IROAsyncInterface)
    ['{10161342-A1A9-4CFB-822F-23B3E17129FA}']
    procedure Invoke_Sum(const A: Integer; const B: Integer);
    procedure Invoke_GetServerTime;
    procedure Invoke_StartTimer;
    procedure Invoke_StopTimer;
    procedure Invoke_ExecuteLongStatementWithProgress;
    function Retrieve_Sum: Integer;
    function Retrieve_GetServerTime: DateTime;
  end;

  { CoNewService_Async }
  CoNewService_Async = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService_Async;
  end;

  { TNewService_AsyncProxy }
  TNewService_AsyncProxy = class(TROAsyncProxy, INewService_Async)
  private
  protected
    function __GetInterfaceName:string; override;

    procedure Invoke_Sum(const A: Integer; const B: Integer);
    procedure Invoke_GetServerTime;
    procedure Invoke_StartTimer;
    procedure Invoke_StopTimer;
    procedure Invoke_ExecuteLongStatementWithProgress;
    function Retrieve_Sum: Integer;
    function Retrieve_GetServerTime: DateTime;
  end;

implementation

uses
  {vcl:} SysUtils, uROClient;

{ CoNewService }

class function CoNewService_Async.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): INewService_Async;
begin
  result := TNewService_AsyncProxy.Create(aMessage, aTransportChannel);
end;

{ TNewService_AsyncProxy }

function TNewService_AsyncProxy.__GetInterfaceName:string;
begin
  result := 'NewService';
end;

procedure TNewService_AsyncProxy.Invoke_Sum(const A: Integer; const B: Integer);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('Sum');

    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'Sum');
    lMessage.Write('A', TypeInfo(Integer), A, []);
    lMessage.Write('B', TypeInfo(Integer), B, []);
    __DispatchAsyncRequest('Sum',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TNewService_AsyncProxy.Retrieve_Sum: Integer;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('Sum');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(Integer), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TNewService_AsyncProxy.Invoke_GetServerTime;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('GetServerTime');

    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'GetServerTime');
    __DispatchAsyncRequest('GetServerTime',lMessage);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TNewService_AsyncProxy.Retrieve_GetServerTime: DateTime;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __response := __RetrieveAsyncResponse('GetServerTime');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('Result', TypeInfo(DateTime), Result, [paIsDateTime]);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TNewService_AsyncProxy.Invoke_StartTimer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('StartTimer');

    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'StartTimer');
    __DispatchAsyncRequest('StartTimer',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TNewService_AsyncProxy.Invoke_StopTimer;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('StopTimer');

    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'StopTimer');
    __DispatchAsyncRequest('StopTimer',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TNewService_AsyncProxy.Invoke_ExecuteLongStatementWithProgress;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('ExecuteLongStatementWithProgress');

    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'ExecuteLongStatementWithProgress');
    __DispatchAsyncRequest('ExecuteLongStatementWithProgress',lMessage, false);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;


initialization
end.
